			   Dart Programming language
.....................................................................................

What is Dart?
   Dart is object-oriented, class based, garbage collected language with c-style   syntax.
   Dart is Object oriented,functionaly style ,General Purpose programming language.
   Dart is strongly typed or static typed ,type inferenced Programming language

Strongly Typed(static typed): The type of variable is verified during compile time.
 -c,c++,java,kotlin,c# etc...

Dynamic Typed (weak Typed):The type of variable is not verified during compile time
-js,python etc...

Compiled code and dart;
.......................

if you take any programming language like java,kotlin,c or c++, when you compile you will get only one intermediate code(Assembly)

java/kotlin ---->compile----> .class(byte code)----Execute
c/c++ ----->compile-------->.obj( Plaftorm(os) Assembly)-------Execute


if you take dart programming language
                       | -----machine code(platform(os) specific assembly))
   dart code----compile| -----javascript 
                       | -----Web assembly

History of Dart:
................
 Dart was designed by Lars Bak and Kasper Lun at google.
 Dart was introduced at Goto conference in Denmark oct 2011, it was released in Nov  2013
 Dart was introduced initally to replace javascript and java script runtime inside  chrome, to embed Dart VM in chrome. Later the plan was dropped to introduce dart  runtime inside  chrome instead to convert dart code into js code.
 
Dart versions

dart 1.0 - first version
dart 1.9
dart 2.0
dart 2.6
dart 3.0
dart 3.X.X....

Types of apps and its Runtime of dart:
.....................................
 Dart Software development(SDK) ships with a standalone dart runtime.
 You can test language features cli environment.
 Dart provides standard libs for building apps


Dart Deployment types:

Deployement type  Target Platform Platform Specific Requries Dart VM
 Javascript         Browser         No                 NO
 Web Assembly       Browser         No                 NO
 Self-contained
 executatble      win,linux,mac     Yes                No
 AOT Module       win,linux,mac     Yes                No
 JIT Module       win,linux,mac     Yes                Yes
 Portable Module  win,linux,mac     NO                 Yes

Based on deployment types , dart can be used to build different types of apps
1.web app - js ,webassembly
2.native -desktop,mobile,tv
................................................................................
   			 Dart setup
..................................................................................

1.Dart SDK
2.IDE - vscode,IntellijIdea,AndroidStudio

Steps:
1.Get The Dart SDK
 1.1. Build from the source code : Get source code of the dart and build accordingly
       -this is only applicable linux.
 1.2.Docker image
 1.3.via Chocolatey 
 1.4.via dowloading the SDK as a zip file
 https://dart.dev/get-dart/archive

Via package managers  for all os
https://dart.dev/get-dart

Note: 

Download zip version and extract it
ADD  dart-sdk\bin in env variable

After installing , you can verify the dart installation.

open cmd prompt
dart --version
Dart SDK version: 3.1.2 (stable) (Tue Sep 12 16:26:23 2023 +0000) on "windows_x64"

Install IntelliJ IDEA Community Edition  or vs code.
.....................................................................................
			Dart Programming language Getting started


dart tool:
 It is used to create ,manage dart projects
-compilation,running...

>dart
A command-line utility for Dart development.

Usage: dart <command|dart-file> [arguments]

Global options:
-v, --verbose               Show additional command output.
    --version               Print the Dart SDK version.
    --enable-analytics      Enable analytics.
    --disable-analytics     Disable analytics.
    --suppress-analytics    Disallow analytics for this `dart *` run without changing the analytics configuration.
-h, --help                  Print this usage information.

Available commands:
  analyze    Analyze Dart code in a directory.
  compile    Compile Dart to various formats.
  create     Create a new Dart project.
  devtools   Open DevTools (optionally connecting to an existing application).
  doc        Generate API documentation for Dart projects.
  fix        Apply automated fixes to Dart source code.
  format     Idiomatically format Dart source code.
  info       Show diagnostic information about the installed tooling.
  pub        Work with packages.
  run        Run a Dart program.
  test       Run tests for a project.

Create Dart Project

dart create --help
Create a new Dart project.

Usage: dart create [arguments] <directory>
-h, --help                       Print this usage information.
-t, --template                   The project template to use.

          [console] (default)    A command-line application.
          [package]              A package containing shared Dart libraries.
          [server-shelf]         A server app using package:shelf.
          [web]                  A web app that uses only core Dart libraries.

    --[no-]pub                   Whether to run 'pub get' after the project has been created.
                                 (defaults to on)
    --force                      Force project generation, even if the target directory already exists.

Run "dart help" to see global options.

create command line project:
............................

dart create --template console myapp 
dart create myapp => Default template is console

dart create myapp
Creating myapp using template console...

  .gitignore
  analysis_options.yaml
  CHANGELOG.md
  pubspec.yaml
  README.md
  bin\myapp.dart
  lib\myapp.dart
  test\myapp_test.dart

Running pub get...
  Resolving dependencies...
  Changed 46 dependencies!

Created project myapp in myapp! In order to get started, run the following commands:

  cd myapp
  dart run

Folders and files:
...................

pubspec.yaml
   -Build script like package.json,pom.xml,gradle.build

name: myapp
description: A sample command-line application.
version: 1.0.0
# repository: https://github.com/my_org/my_repo

environment:
  sdk: ^3.1.2

# Add regular dependencies here.
dependencies:
  # path: ^1.8.0

dev_dependencies:
  lints: ^2.0.0
  test: ^1.21.0


test
  -Contains unit and integration testing files
lib
  -contains utility apis
bin
  -contains source of code app and entry point of dart application.

All dart programs are saved with "fileName.dart"

Every dart App must have entry point called "main"
.....................................................................................

coding style -c,c++,kotlin

General function syntax:
returnType functionname(){
   //body of the function
}
main function:

bin/myapp.dart
void main() {
  //code
  print("Hello Dart");
}

How to run dart program?

dart run  -->Will pick main program from the bin folder

dart run [options] [DART_FILE] [args]

E:\session\IBM\2023\Oct\DartAndFlutter\myapp>dart run
Building package executable...
Built myapp:myapp.
Hello Dart

E:\session\IBM\2023\Oct\DartAndFlutter\myapp>dart run bin/myapp.dart
Hello Dart

main function can take command line args'
........................................

void main(List<String> args) {
  print(args);
  print("Hello Dart with args");
}

E:\session\IBM\2023\Oct\DartAndFlutter\myapp>dart run bin/myapp.dart welcome how are you
[welcome, how, are, you]
Hello Dart with args
...................................................................................
			  Dart compilation

As we disucssed already, the dart code can be compiled into multiple formats.

dart compile --help
Compile Dart to various formats.

Usage: dart compile <subcommand> [arguments]
-h, --help    Print this usage information.

Available subcommands:
  aot-snapshot   Compile Dart to an AOT snapshot.
  exe            Compile Dart to a self-contained executable.
  jit-snapshot   Compile Dart to a JIT snapshot.
  js             Compile Dart to JavaScript.
  kernel         Compile Dart to a kernel snapshot.

Run "dart help" to see global options.

How to compile the dart code into platform specific(exe):
..........................................................

dart compile exe bin/myapp.dart
Generated: e:\session\ibm\2023\oct\dartandflutter\myapp\bin\myapp.exe

How to run compiled exe:
E:\session\IBM\2023\Oct\DartAndFlutter\myapp\bin>myapp.exe hello
[hello]
Hello Dart with args

How to compile the dart code into js:
....................................
dart compile js bin/myapp.dart

how to run compiled javascript?

you can run js code using browsers or node.js runtime.

Node:
E:\session\IBM\2023\Oct\DartAndFlutter\myapp>node out.js
[]
Hello Dart with args

Portable Modules(kernel): Platform independent;
..............................................
>dart compile kernel bin/myapp.dart
Compiling bin/myapp.dart to kernel file bin/myapp.dill.

How to run dart kernel module:
dart run bin/myapp.dill
[]
Hello Dart with args
....................................................................................

Learning Path:
1.Dart language fundamentals
2.Dart Object oriented programming
3.Dart functional programming 
4.Dart Async Programming
5.Datastructures and collections
6.Exception Handling

Language Fundamentals:

1.Variables
2.Type system
3.literals (values)

Variable declaration: Syntax 1

Type variableName = value(literal)

Type:
 Java,Js like languages has two types of datatypes
1.primitive types - int,float,char,boolean
2.reference types - object types

In Dart everything is object, no Primitive Types,Mostly Reference Types

Built in Types:
...............
1.Numbers   
    int,double
2.Strings (String)
3.Booleans (bool)

Advanced Types:
1.List
2.Set
3.Map
4.Symbol
5.Null
6.Records
7.Runes


Eg:
void main() {
  //declare variable
  int a = 10;
  double d = 10.5;

  print("int type" + a.toString());
  print("doubel type" + d.toString());
}


Variable declaration: Syntax 2

Type inference syntax: The type of variable is "understood" based on the value we assign

var variableName = value(literal)
void main() {
  //declare variable
  int a = 10;
  double d = 10.5;

  print("int type" + a.toString());
  print("doubel type" + d.toString());

  //type inference syntax
  var b = 10;
  var c = 134.78;
}

int:
 =>64 bit in case of native platform , in case if the code converted into js size    would be 64 bit floating point

double
 =>64 bit floating point in all platforms 

Note: type inference syntax is mostly recommended.
...................................................................................

Strings:
=>16 bit UTF-16 code units
=>You can use '' or ""
=>String concatnation can be done using + operator or string interploation.

String interploation is done using ${expression}
void main() {
  String str = 'Hello';
  var name = "Subramaian";
  //print values : Using + operator
  print("Name " + name);
  //using string interpolation
  print("Name ${name}");
  print("Name $name");

}

Multi line Strings:
....................
""" -triple quotes

void main() {
  String str = 'Hello';
  var name = "Subramaian";
  //print values : Using + operator
  print("Name " + name);
  //using string interpolation
  print("Name ${name}");
  print("Name $name");

  var html = """
       <html>
         <head>
        <title>Hello</title>
        </head>
        <body>
        <h1>Hello $name</h1>
        </body>
        </html>
  """;
  print(html);
}
.................................
Booleans:
=>1 bit value
=>true or false 

void main() {
  var isValid = true;
  var isEnabled = false;
  print("Is Valid $isValid");
  print("Is Enabled $isEnabled");
}
...................................................................................
			Variable reinitalization
..................................................................................

final and const:

 Instead of using var keyword we can use final or const

final :
  final j = 10;
  print("j $j");
  j = 33434;

compile time error:
10:3: Error: Can't assign to the final variable 'j'.
  j = 33434;

const:
   //const d = 10;
  const int d = 10;
  print("d $d");
  //d =90; - cant be reinitialized

const vs final:
..............
final variables can only be set once and it its intialzed when accessed : lazy
const variables are implicitly final but it is a compile time constant: eagar.

const are intialized during compile time 
final are intialized during runtime 

Testing: 
 How to know final is lazy, const is eager.

void main() {
  var i = 10;
  print("i $i");
  //reinitalize the variable
  i = 90;
  print("i $i");

  //without type: type inferenence
  //final j = 10;
  final int j = 10;
  print("j $j");
  //j = 33434;

  //const d = 10;
  const int d = 10;
  print("d $d");
  //d =90; //- cant be reinitialized
}
.....................................................................................
				 Null
....................................................................................

What is null?

  Null itself is value, Its type is Object.
  Null itslef is object.

History Of Null:

  In computing, a null pointer or null reference is a value saved for indicating that the pointer or reference does not refer to a valid object(value).

In 2009, Tony Hoare stated that he invented the null reference in 1965 as part of the ALGOL W language. 

In that 2009 reference Hoare describes his invention as a "billion-dollar mistake":

reference: https://en.wikipedia.org/wiki/Null_pointer

.....................................................................................
			How to handle Null?

"Null" Reference is unavoidable in any Object Oriented Systems like c++,java,C#,Kotlin etc...

Handling null is more challange

In java ,C++,C#, in these languages if you call any properties on null object meaning that the variable points null object, will throw error/Exception.

if exception happens , the program will be terminated with reporting.

In java:
 
 Employee emp=null;
 emp.id =1;

When you run this code you will get nullPointer Exception

Solution:
  if(emp!=null){
	emp.id=1
  }  
The above code might be duplicated across many places.

After java, many languages started thinking that how to safely handle null.

Dart and Null:
..............
Since Dart is  Object oriented, there is possiblity of null.

Can we declare null value to a variable?

void main(){
  int a = null;  
}

Yes and No, by default a variable cant hold "null".

What if i want to initalize null?

void main() {
  int? a = null;
  var b = null;
}
Note:
 with type annotation we have to use "?"
 with var keyword it is implicit.


when you declare a variable without initalizing any value

void main() {
   int c;
}
no compile time error.

Note:
 You must initialize the variable before using them. Value can be null or type releated value.

void main() {
  int? c;
  print("c $c");
}
Here c is implicitly assigned with null.
 
void main() {
  var d;
  print("d ${d}");
}

Here d is implicitly assigned with null 

Initallly you declare null and later you can reinitalize with values.

void main() {
  int? c;
  print("c $c");
  c =10;
  print("c $c");

  var d;
  print("d ${d}");
  c=20;
  print("d ${d}");

}

Property access on nullable object:
...................................

void main() {
  //String? name = "subramanian";
  String? name = null;
  print("Name $name");
  print("Name ${name.toUpperCase()}");
}

Compiler gives error
The method 'toUpperCase' can't be unconditionally invoked because the receiver can be 'null'

Solution:
Try making the call conditional (using '?.') or adding a null check to the target ('!') or test with if condition of not null.

 //solution -1
  if (name != null) {
    print("Name ${name.toUpperCase()}");
  }

Solution 2
print("Name ${name?.toUpperCase()}");

Solution 3:
print("Name2 ${name!.toUpperCase()}");

.....................................................................................
				Late variables
.....................................................................................

late modifier has two use cases

1.Declaring non nullable variable that is initalized after its declaration
2.Lazily initializing variable : during runtime.

//Script variables
//String name = "Subramanian";
//Script variables
//String name = "Subramanian";
late String name;

void main() {
  name = "Subramanian";
  late String city;
  print(name);
  city="Coimbatore";
  print(city);
}

if you fail to initialize a late variable, a runtime error occurs when the variable is used.

late String name="something";

when you mark a variable as late but initalize it at its declaration, then the initializer runs the first the variable is used.
....................................................................................
				Operators
....................................................................................

Most of the operators are dervided c and c++,java 

Arithmetic Operators:
+,-,-expersion(unary),* , /, ~/(div return int as res),% 

void main() {
  var x = 10;
  var y = 2;
  print("Add ${x + y}");
  print("Subtract ${x - y}");
  print("Multiply ${x * y}");
  print("Div ${x / y}");
  print("Remainder ${x % y}");

}
Equality and Relational operators:

== 
!=
>
<
>=
<=
void main() {
  var x = 10;
  var y = 20;
  var c = x == y;
  print("c $c");
}

Type Test Operators:
...................
Checking data type of variable during runtime

as - Type cast operator.
is - True if the object has specified type
is! - true if the object does not have the specified type.

void main() {
  int a = 10;
  print("${a is int}");
}

Assignment operators

=
*=,+=,%=
??=

//Assign value to b if  b is null other wise b stays the same
b??=value

void main() {
  int? a = null;
  a ??= 0;
  print("a $a");
}

Logical Operators:

! - not
&& - And
|| - OR

Conditional Expressions (tenary)
...............................
=> condition ? expr1 : expr2
    if condition is true, evaluates expr1 other wise expr
=> expr1 ?? expr2
   if expr1 is non null return its null, otherwise evaluates and returns value of expr

void main() {
  var isValid = true;
  var result = isValid ? "Valid" : "InValid";
  print("result $result");

  var name;
  var res = name ?? "Subramanian";
  print("Name is $res");
}
............
Cascade Operators: to be discussed in oo.

Other Operators:
................
() - function application operator
[] - subscript operator
?[] - conditional subscript
. - Member access operator
?. - conditional Member access
! -Null assertion opertor
....................................................................................
				Functions
....................................................................................

Dart is a true object-oriented language, so even functions also Objects and has type, "Function".

How to declare functions?

returnType funName(args) {
  //function body
  return statement
}

//declaration
void sayHello() {
  print("Hello");
}

void sayHai() {
  print("hai");
}

//main function
void main() {
  //invocation
  sayHello();
  //
  sayHai();
}

Function Parameters and Args:
.............................

void add(int a, int b) {
  int c = a + b;
  print("C $c");
}

void calculate(var a, var b) {
  int c = a * b;
  print("c $c}");
}

void main() {
  add(10, 10);
  calculate(10, 10);
  calculate("12", "10");
}

Note:

 Function args are declared with type - strong typing , so that we can only pass that only specific type - if you pass different types, you get compile time error.

void add(int a, int b) {
  int c = a + b;
  print("C $c");
}
add(10, 10);

 Function args are declared with "var" - dynamic typing , so that we can  pass that  any  type - if you pass different types, you wont get compile time error.
 There is possiblity it causes runtime error.
....................................................................................

Args and null : nullable args:
................................

void sayHello(String? name) {
  var res = name ?? "Your Name";
  print("$res");
}

void main() {
  sayHello("Subramanian");
  sayHello(null);
}
..................................................................................

Function Parameters:

1.Named parameters

Named parameters must be enclosed in curly braces ('{' and '}').
When we use Named parameters , we can initalize the  variables with default values, so that we can omit those variables.

Named Optional Parameters:
 => we we defining function, use {param1,param2...} to specify named parameters
 => we we calling functoin you can specifiy the parameter name:value, if you want you     can even skip (optional Parameters)

void sayName({String? name = "Your Name"}) {
  print("Name is $name");
}

void main() {
  sayName(name: "Subramanian");
  sayName();
}

void sayName({String? name = "Your Name"}) {
  print("Name is $name");
}

void widget(
    {String? name = "Layout",
    int? height = 0,
    int? width = 0,
    String? theme = "light"}) {
  print("name $name");
  print("height $height");
  print("width $width");
  print("theme $theme");
}

void main() {
  sayName(name: "Subramanian");
  sayName();
  //widget(name, height, width, theme);
  widget();
  widget(name: "Tab", theme: "dark");
  widget(name: "Panel", width: 100, height: 200, theme: "light");
}

...........................................................................

Named and Required Parameters:
.............................
void httpClient(
    {required String? url,
    String? method = "GET",
    required String? payload,
    String? headers = "headers"}) {
  print("url $url");
  print("method $method");
  print("payload $payload");
  print("headers $headers");
}

void main() {
  httpClient(url: "http://www.mockapi.com/users", payload: "Users");
  httpClient(url: "http://www.mockapi.com/users", payload: "Users",method: "POST");

}
....................................................................................

Positional Parameters:
......................
 General Function args are Positional.

void sendMail(String from, String to, String msg) {
  print("From $from");
  print("To $to");
  print("Message $msg");
}

void main() {
  sendMail("admin@ibm.com", "foo@ibm.com", "You got a mail");
}

Postional Optional Parameter:
.............................
Wrapping a set of function parameters in [] marks them as optional positional parameter. if you dont provide default value, their type would be null.

void sendMail(String? from, String? to, String? msg, [String? device="Mobile"]) {
  print("From $from");
  print("To $to");
  print("Message $msg");
  print("Device $device");
}

void main() {
  sendMail("admin@ibm.com", "foo@ibm.com", "You got a mail");
  sendMail(null, null, null);
  sendMail("admin@ibm.com", "foo@ibm.com", "You got a mail","Computer");
}

Note:
 Postitional optional parameters must go last arg only
 Postitional optional parameters cant mix in between.
 All Postitional args can be optional

...................................................................................
			Return Type
....................................................................................

Function can return any type and also can return "void"
No return statement means , by default void.

void :
// void sayHello(){
//   print("hello");
//   return;
// }
sayHello() {
  print("hello");
  return;
}

main() {
  sayHello();
}
Note: you can even remove void keyword.

// void sayHello(){
//   print("hello");
//   return;
// }
sayHello() {
  print("hello");
  return;
}

int add({int? a = 0, int? b = 0}) {
  return a! + b!;
}

main() {
  sayHello();
  print(add());
  //print(add(a:null,b:null));
  print(add(a: 3, b: 4));
}
..................................................................................
			Control Flow - Loops and Branches
..................................................................................
Loops:
 -for
 -while and do while
 -break and continue

Branching:
  if and switch
  Exceptions- try,catch,and throw.


Loops:
void main() {
  //Loops - for
  for (int i = 0; i < 5; i++) {
    print("i $i");
  }
  for (var i = 0; i < 5; i++) {
    print("i $i");
  }
  // for (final i = 0; i < 5; i++) {
  //   print("i $i");
  // }
  var i = 100;
  while (i > 10) {
    print("while $i");
    i++;
  }
}

Break and Continue:
while(true){
 if(condition) break;
}
...............

Branches:
1.if statements -  if , if..else, if..elseif..else
2.if..case statement
3.switch case statement and expressions


if...
main() {
  //if...else
  var salary = 15000;
  if (salary > 20000) {
    print("Good Salary");
  } else {
    print("You need more ");
  }
  //if else if
  var marks = 80;
  if (marks >= 90 && marks < 100) {
    print("A +");
  } else if (marks >= 80 && marks < 90) {
    print("A");
  } else {
    print("No grade");
  }
}

if...case: We can see later after pattern matching concept
..
........................................

Switch:
 Switch Statement
 Switch Expressions

main() {
  String grade = 'A';
  switch (grade) {
    case 'A':
      print("Excellent");
      break;
    case 'B':
      print("Very Good");
      break;
    case 'C':
      print("Good");
      break;
    default:
      print("No Grade is found");
  }
}
.....

Switch Expressions:
  A Switch expression produces a value based on the expression body of whichever case catches.

eg:

 var r = switch(x) {}
 print(switch(x){});
 return switch(x){};

int getDayofWeek(String dayOfWeek) {
  return switch (dayOfWeek) {
    'Monday' => 1,
    'Tuesday' => 2,
    'Wednesday' => 3,
    'Thursday' => 4,
    'Friday' => 5,
    'Saturday' => 6,
    'Sunday' => 7,
    _ => 10
  };
}

void main() {
  var dayOfWeek = 'Monday';
  var result = switch (dayOfWeek) {
    'Monday' => 1,
    'Tuesday' => 2,
    'Wednesday' => 3,
    'Thursday' => 4,
    'Friday' => 5,
    'Saturday' => 6,
    'Sunday' => 7,
    _ => 10
  };
  print("$result");
  print(getDayofWeek("Friday"));
}

Differences between switch statement and switch expressions:

1.cases do not start with const keyword
2.a case body must be single expression of a series of empty cases
3.each must have body;
4.case patterns must be separated by => instead of ":"
5.default case is replaced by "_" 
.....................................................................................
			 Functional Programming in Dart
.....................................................................................

What is Functional Programming?
   Functional Programming is one of the programming paradigm/style to build apps.

Popular Programming styles/paradigms:
.....................................
1.Object Oriented Programming
2.procedural Programming
3.Functional Programming
etc.....

Programming languages are based on those paradigms only.

if you take any programming language , which follows one or many programming styles.

c language follows procedural style, so we can call c is procedural language.
c++ language follows object oriented programming so we can call c++ is object oriented
java was object oriented, now java is functional and object oriented.
javascript is object based,functional style
kotlin is object oriented , functional style

if a language mixes one or more programming paradigm is called "hybrid languages".

What about dart?
  
 Dart is object oriented, functional style programming language.

What it is functional programming?
   Functional programming principles and patterns implemented from the mathmatics called  "Lambda Calculs".

Lambda calculus (also written as Î»-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution

Why Lambda Calculs was created?
  Lambda calculus was created to "simulate" computer program data processing.
  Lambda calculus provides the abstract computer.


In 1950's Based on Lambda calculus , new programming style and language was created.

1.LISP - First functional programming language.

Based LISP many languages were created.......

1.CommonLisp
2.Lisp For JVM-Clojure
3.Haskell
4.javascript
5.JVM
   Groovy,scala ,Kotlin, Java 8 ,Closure......

Now Dart is also based on FP programming ......
....................................................................................
			 Principles of Functional Programming
....................................................................................

1.Functions are first class citiziens
2.Referetial transparency
3.Pure functions
4.No loops, Recurssive functions.

Languages follow all above principles are called "Pure functional Language" other wise functional style language.

Dart is functional style language.
..................................................................................
Dart Functional Programming implementation:

1.Functions are first class citiziens

 What is first class citizen(special).
    Functions are passed around (in , out).

This means the language supports passing function as args to other functions, returning them as the values from functions and assigning them to variables or storing them in data structure.
 
 "Functions are literals , means that functions are value like int,double string"

for eg:
 var a=10;
 var is keyword
 a is variable
 10 is value

In Dart functions are first class objects(values):
..................................................
You can assign function into variable , pass them as parameter to another function, and you return from another function.

1.How to assign function into a variable

void sayHello() {
  print("Hello");
}

void main() {
  //invoke function
  //sayHello();
  //Here var is keyword and hello is variable , sayHello is function
  var hello = sayHello;
}

hello variable can be used to invoke that function.
import 'FunctionReturns.dart';

void sayHello() {
  print("Hello");
}

void main() {
  //invoke function
  //sayHello();
  //Here var is keyword and hello is variable , sayHello is function
  var hello = sayHello;
  hello();
  //Type Annotation
  Function tmpHello = sayHello;
  tmpHello();

  //way of calling functions: using variable hello()
  //using variable.call()
  hello.call();
  tmpHello.call();
}

.................................................................................
			 Anonymous Functions
................................................................................

Most of functions are "named" functions, functions with name, you can create a nameless function called a "anonymous functions".

Anonymous functions other wise called as "lambda functions or closure".

Anonymous functions are similar to named functions which takes args,parameters,return values optional and named args

Syntax:
var variable=([type ? variable]) {

};

eg:
//anonymous function
Function hello = () {
   print("Hello");
};
var hai = (){
  print("Hai");
};

void main() {
  hello();
  hai();
}

....

Anonymous functions within another function:

void main() {
  //anonmous function
  var hello = () {
    print("Hello");
  };
  hello();
}

Args ,parameters in anonyous functions :Positional and Named
//positional 
var add = (int a, int b) {
  int c = a + b;
  print("c $c");
};
//Named parameters with default values
var multiply = ({int? a = 0, int? b = 0}) {
  int c = (a ?? 0) * (b ?? 0);
  print("a=$a b=$b c $c");
};

void main() {
  add(10, 10);
  multiply();
  multiply(a: 10, b: 20);
  multiply(a: 10, b: null);
}
...................................................................................
			   Returning values from anonymous

//positional
var add = (int a, int b) {
  int c = a + b;
  print("c $c");
};
//Named parameters with default values
// var multiply = ({int? a = 0, int? b = 0}) {
//   int c = (a ?? 0) * (b ?? 0);
//   // print("a=$a b=$b c $c");
//   return "a=$a b=$b c $c";
// };
Function multiply = ({int? a = 0, int? b = 0}) {
  int c = (a ?? 0) * (b ?? 0);
  // print("a=$a b=$b c $c");
  return "a=$a b=$b c $c";
};

void main() {
  add(10, 10);
  // multiply();
  // multiply(a: 10, b: 20);
  // multiply(a: 10, b: null);
  print(multiply());
  print(multiply(a: 10, b: 20));
  print(multiply(a: 10, b: null));

}
..................................................................................
				Arrow Functions
...................................................................................
//if function has single line expression
var greet_ = () {
  print("Hello");
};
//single line expression are replaced by arrow
// var greet = () => {
//   print("Hello")
// };
var greet = () => print("Hello");
var add = (int a, int b) => a + b;
var multiply = ({int a = 0, int b = 0}) => "c = ${a * b}";

void main() {
  greet();
  print(add(10, 10));
  print(multiply(a: 10, b: 10));
}
....................................................................................
			 Higher Order functions
....................................................................................

Higher order function means passing function as parameter to another function,since function is value.

void callback(Function cb) {
  
}

void main() {
  callback();
}

There are two patterns to pass function as paramter..

1.via variables which hold functions
2.via functions directly

void callback(Function cb) {}

void add(int a, int b) {
  
}

void main() {
//  callback();
  add(10, 10); //passing values directly
  int x = 10;
  int y = 20;
  add(x, y);
}
.....
Basic Higher order function:
void callback(Function cb) {
  cb();
}

//via variable
Function myFun = () {
  print("My fun");
};
Function myArrowFun = () => print("My fun");

void main() {
  callback(myFun);
  callback(myArrowFun);
}
.....................................................................................
Higher Order Functions args and parameters
....................................................................................
//Normal function as Higher order function
void callback(Function f) {
  f("Hello");
}

//Anonymous function as Higher Order function
Function map = (Function transform) {
  transform();
};
//Arrow function as Higher order function
Function filter = (Function filter) => filter();

var hello = (String name) {
  print("Your Name is $name");
};
var hai = (String name) => print("Your Name is $name");

void main() {
  callback(hello);
  callback(hai);
  //via value
  callback((String name) {
    print("Your Name is $name");
  });
  callback((String name) => print("Your Name is $name"));

  map(() => print("map transform"));
  filter(() => print("filter "));
}
.....................................................................................

Higher order functions with more args,params,with nullable,Named , Named with Optional,Optional Parameters

Optional:
//Hihger order functions with named more args
//optional parameter
void exec(int no, Function callback) {
  callback(no);
}

void doubleIt(int i) => print(i * i);

void main() {
  exec(10, doubleIt);
}

Optional Parameter with Non Nullable:
......................................
//optional parameter
void exec(int? no, Function? callback) {
  //callback!(no);
  if (callback != null) {
    callback(no);
  }
}

void doubleIt(int i) => print(i * i);

void main() {
  exec(10, doubleIt);
}
........................


Named Parameter and Higher Order function with Non Nullable:
//Named Parameter
void asyncFun({String? name = "Subramanian", Function? f}) {
  if (f != null) f();
}

void main() {
 asyncFun(
      name: "Subramanian",
      f: () {
        print("Hello");
      });
}
More complex:
void login(
    {String? userName = "",
    String? password = "",
    Function? resolve,
    Function? reject}) {
  if (userName == 'admin' && password == 'admin') {
    resolve!("Login success for $userName");
  } else {
    reject!("Login failed,Retry");
  }
}

void main() {
  login(
      userName: "admin",
      password: "admin",
      resolve: (String status) {
        print(status);
      },
      reject: (String error) {
        print(error);
      });

  login(
      userName: "foo",
      password: "bar",
      resolve: (String status) {
        print(status);
      },
      reject: (String error) {
        print(error);
      });

}
...................................................................................
				Lexical scope and Lexical Closures
...................................................................................

Before Moving into lexical concept , we need to learn , nested functions.

Inner functions or Nested Functions:
....................................

functions are within another function.

counter() {
  print("counter outter fun");
  inc() {
    print("inc inner function");
  }
  inc();
}

void main() {
  counter();
}

Inner functions are defined within outter function is available only with in inner functions.

How to call inner functions?

->within outter function
->return that function as value - Higher order function.

Function like() {
  // return () {
  //   print("inner ");
  // };
  return () => print("inner ");
}

void main() {
  Function inc = like();
  inc.call();
}

Passing values into inner functions:
....................................

Function like() {
  // return (int value) {
  //   return value + 1;
  // };
  return (int value) => value + 1;
}

void main() {
  counter();
  // inc();
  Function inc = like();
  print(inc.call(12));
  print(inc(33));
}
...
Anonmous functions return another funcition:
Function like = () {
  return (int value) => value + 1;
};

void main() {
  counter();
  // inc();
  Function inc = like();
  print(inc.call(12));
  print(inc(33));
}

Arrows functions return another functions:
Function like = () => (int value) => value + 1;

void main() {
  counter();
  // inc();
  Function inc = like();
  print(inc.call(12));
  print(inc(33));
}
....................................................................................
			 Lexical Scope
....................................................................................

The word "lexical" means static.
There are two way of binding expressions with variables
1.during compile or early binding -  lexical 
2.during runtime or late binding - dynamic

"Dart is lexically scoped language", meaning the variables are bound with the scope of function during compile time".
...................................................................................				 Lexical Closure(closed over)
..................................................................................
1.A  Closure is a function (inner function) that access to the parent scope,even after the scope has closed.
 "Inner functions access outter function variables which is bound to outter scope"
2.A Closure is a function that has access to variables in its lexical scope, even when the function is used outside of the original scope.



Variables Scope:
void main() {
  String message = "Dart";
  showMessage() {
    String message = "Dart is awesome";
    print("$message");
  }
  showMessage();
}

Variable lookup and scope :

String message = "Dart!!!";

void main() {
  String message = "Dart";
  showMessage() {
    String message = "Dart is awesome";
    print("$message");
  }
  showMessage();
}

Here message variable is defined inner function, when the variable is access within that function , always local scope wins, if variable is not found it looks immediate parent, if not it looks its immediate, so on until match is found,if no match found, it willthrow error.

String message = "Dart!!!";

Function makeAdder(int addBy) {
  //inner function :closure which going to access outter function variable it could be parameter
  //or local variable
  // return (int i) {
  //   return addBy + i;
  // };
  return (int i) => addBy + i;
}

void main() {
  String message = "Dart";
  showMessage() {
    //String message = "Dart is awesome";
    print("$message");
  }

  showMessage();
  Function adder = makeAdder(10);
  //call inner functtion
  print("inner calling ${adder(2)} ");
  print("inner calling ${adder(23)} ");
  print("inner calling ${adder(2232)} ");
  print("inner calling ${adder(22)} ");
  print("inner calling ${adder(52)} ");
  print("inner calling ${adder(20)} ");
}
.....................................................................................
			Object oriented Programming in Dart
.....................................................................................
Dart is fundamentally object oriented language, in dart every thing is object.

OO features:
1.Abstraction
2.Encaspulation
3.Typing
4.Hierachy
5.Modularity
6.Concurrency
7.Persistency

1.Abstraction
  Abstraction is implemented via classes.

class declaration
variables and methods- instance variables and static variables
methods
constructors
object creation


simple class declaration and object creation:
class User {}

void main() {
  //object creation
  //User is type ; user1 is reference variable ; new is keyword ; User() is constructor call
  User user1 = new User();
  var user2 = new User();
  //new keyword is not necessary ; not recommend
  User user3 = User();
}

Declare instance variables and nullable properites;

class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;
}

main() {
  User user = User();
  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

}

id null
name null
age null
city null
.....................................

How to initalize the instance variables.

1.within class 
2.outside class; after object creation
3.during object creation; constructors



1.within class
class User {
  //instance variables
  int? id = 1;
  String? name = "Subramnaian";
  int? age = 43;
  String? city = "Coimbatore";
}

main() {
  User user = User();
  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}

2.outside class: after object creation
class User {
  //instance variables
  int? id = 1;
  String? name = "Subramnaian";
  int? age = 43;
  String? city = "Coimbatore";
}

main() {
  User user = User();
  //after object creation using instance variables
  user.id = 100;
  user.name = "John";
  user.age = 34;
  user.city = "Coimbatore";
  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}
....................................................................................
				 Methods
...................................................................................
if functions are declared within class called methods, all function syntaxs are valid.

Types of methods

1.instance methods
2.static methods 

1.biz methods
2.state initalizer - setter and getter


biz instance methods
biz static methods.



biz instance methods:

class UserAPI {
  // String findAll() {
  //   return "findAll";
  // }
  String findAll() => "findAll";

  String save(String? name) => "$name";
}

void main() {
  UserAPI userAPI = UserAPI();
  print(userAPI.findAll());
  print(userAPI.save("Subramanian"));
}
.........
Setters and Getters are used to initalize the state(instance) variables.

By default dart uses internally setters and getters, you dont to use. but some times if i want to use setters and getters for some customization.

Setters = > to set value
Getters = > to read value.

Getters:
 return_type get property_name {

 }
class User {
  String? firstName;
  String? lastName;

  //getter
  String get fullName => "$firstName $lastName";
}
main(){
  User user = User();
  user.firstName ="Subramanian";
  user.lastName="Murugan";
  //call getter
  print(user.fullName);

}

setter:

void set property_name(value) {

}
"this" keyword used to refer object instance variables with methods.
class User {
  //String? fname;
  String? _firstName;
  String? lastName;

  //setter
  set firstName(String firstName) {
    print("setter is called");
    //this keyword is implicit
    // this._firstName = firstName;
    _firstName = _firstName;
  }

  //getter
  String get fullName => "$_firstName $lastName";
}

main() {
  User user = User();
  user.firstName = "Subramanian";
  user.lastName = "Murugan";
  //call getter
  print(user.fullName);
}

"_" notation is used to declare variables are "private" variables

...............................................................................
static variables and methods:
class Message {
  static String warning = "Warning";
  static String success = "Success";

  static void inc() {
    print("page count");
  }
}

void main() {
  print(Message.success);
  print(Message.warning);
  Message.inc();
}
...................................................................................
			    Constructors
...................................................................................

Constructors are special methods used to initalize the objects.

Constructor call basic syntax;
  new User();
  User();


How to declare constructors?

dart provides many ways /types of constructors

1.Simple constructor
  Should match ClassName.

Using constructors we can initalize the variables.

class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;
}

main() {
  User user = User();
  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}

Here there is no constructor, means there is default constructor is supplied.

Argument Constructors:
......................
1.Optional args and positional constructors
2.Named args


1.Optional args and positional constructor

class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;

  User(int id, String name, int age, String city) {
    // this.id = id;
    // this.name = name;
    // this.age = age;
    // this.city = city;
    this.id = id;
    this.name = name;
    this.age = age;
    this.city = city;
  }
}

main() {
  User user = User(1, "Subramanian", 43, "Coimbatore");
  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}

Short cut: you dont need to initalize the variables within constructors 
class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;

  User(this.id, this.name, this.age, this.city);
}

main() {
  User user = User(1, "Subramanian", 43, "Coimbatore");
  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}
..........................................

Named and Default values:
.........................
class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;
  //Named constructors with default value
  User({this.id = 0, this.name = "name", this.age = 18, this.city = "city"});
}

main() {
  User user = User(id: 1, name: "Subramanian", age: 43, city: "Coimbatore");

  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

  user = User();
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

  user = User(id: 1, name: 'Raj', age: 33);
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}

Note:
 One SIngle named with default value constructors are used to initalize the object in no of ways - Constructor overloading.
..................................................................

Named Constructors:

class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;
  //Named constructors with default value
  User({this.id = 0, this.name = "name", this.age = 18, this.city = "city"});
  User(){}
}

Here you can see that there is two constructors, which is not allowed in dart.
multiple constructors not allowed.

What if i want multiple constructors, thats where "Named Constructors are used"

class User {
  //instance variables
  int? id;
  String? name;
  int? age;
  String? city;

  // Named parameter constructors with default value
  User({this.id = 0, this.name = "name", this.age = 18, this.city = "city"});

  //Named constructors
  User.fromJson(
      {this.id = 0, this.name = "name", this.age = 18, this.city = "city"});

  //Named Constructors without any args
  User.createUser()
      : id = 1,
        name = "Ram",
        age = 18,
        city = "Chennai";
}

main() {
  User user = User(id: 1, name: "Subramanian", age: 43, city: "Coimbatore");

  //access variables
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

  user = User();
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

  user = User(id: 1, name: 'Raj', age: 33);
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

  user = User.fromJson(id: 1, name: 'Raj', age: 33);
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");

  user = User.createUser();
  print("id ${user.id}");
  print("name ${user.name}");
  print("age ${user.age}");
  print("city ${user.city}");
}
...................................................................................
				Constant Constructors
...................................................................................

constant constructors are constructors that creates constant object.
Constant object , whose value cant be changed.

Rules:
1.All properties of the class must be final
2.it does not have any body
3.only class containing const constructor is initalized using the const keyword
4.when we create object we can use const keyword to improve performance.

class Point {
  final int x;
  final int y;

  //constant constructors
  const Point(this.x, this.y);
}

//
main() {
  Point point = Point(1, 3);
  print("X ${point.x} Y ${point.y}");
  //point.x =10;
}
.....................................................................................

const infront of object creation:

Point point = const Point(1, 3);

const keyword is used infront of constructor call, to improve performance, that means objects are immutable.

once the constructor is called with same parameter no of times, which does not create object every time : immutablity.


class Point {
  final int x;
  final int y;

  //constant constructors
  const Point(this.x, this.y);
}

//
main() {
  //without immutable
  Point p1 = Point(1, 3);
  Point p2 = Point(1, 3);
  //check p1 and p2 both points one object or many objects
  print("p1 hashcode ${p1.hashCode} ");
  print("p2 hashcode ${p2.hashCode} ");

}
output:
p1 hashcode 994922061 
p2 hashcode 384700281 

here p1 and p2 are pointing two different objects.

what if i want to create only one object , irrespect of no of constructors.


  Point p3 = const Point(1, 3);
  Point p4 = const Point(1, 3);
  //check p1 and p2 both points one object or many objects
  print("p3 hashcode ${p3.hashCode} ");
  print("p4 hashcode ${p4.hashCode} ");

p3 hashcode 28326995 
p4 hashcode 28326995 

Here both object points same hashcode, meaning that only one instance is available.

class Point {
  final int x;
  final int y;

  //constant constructors
  const Point(this.x, this.y);
}

//
main() {
  Point point = Point(1, 3);
  print("X ${point.x} Y ${point.y}");
  //point.x =10;

  //without immutable
  Point p1 = Point(1, 3);
  Point p2 = Point(1, 3);
  //check p1 and p2 both points one object or many objects
  print("p1 hashcode ${p1.hashCode} ");
  print("p2 hashcode ${p2.hashCode} ");

  //immutable
  Point p3 = const Point(1, 3);
  Point p4 = const Point(1, 3);
  //check p1 and p2 both points one object or many objects
  print("p3 hashcode ${p3.hashCode} ");
  print("p4 hashcode ${p4.hashCode} ");
}

X 1 Y 3
p1 hashcode 710306973 
p2 hashcode 1006090697 
p3 hashcode 497022349 
p4 hashcode 497022349 

const constructors with named parameters with default value:

class Point {
  final int? x;
  final int? y;

  //constant constructors
  //const Point(this.x, this.y);
  const Point({this.x = 0, this.y = 0});
}

//
main() {
  Point point = Point(x: 1, y: 3);
  print("X ${point.x} Y ${point.y}");
  //point.x =10;

  //without immutable
  Point p1 = Point(x: 1, y: 3);
  Point p2 = Point(x: 1, y: 3);
  //check p1 and p2 both points one object or many objects
  print("p1 hashcode ${p1.hashCode} ");
  print("p2 hashcode ${p2.hashCode} ");

  //immutable
  Point p3 = const Point(x: 1, y: 3);
  Point p4 = const Point(x: 1, y: 3);
  //check p1 and p2 both points one object or many objects
  print("p3 hashcode ${p3.hashCode} ");
  print("p4 hashcode ${p4.hashCode} ");
}
...................................................................................
				Factory Constructors
...................................................................................

Factory constructors are used to create objects in more flexiable way. 

Factory constructors are used to create instance of class or even sub class.

Rules;
1.Factory constructor must return an instance of a class or sub class
2.you cant use this keyword inside factory constructor
3.it can be named or unamed and called like normal constructors
4.it cant access instance members of the class
5.private constructors are used to inside factory constructors

Private constructors:
1. private constructors are not availble outside the class , so that we cant create object , via factory only we can call private constructors.

classname._internal();


class Area {
  final int length;
  final int breadth;
  final int area;

  //private constructor
  const Area._interal(this.length, this.breadth) : area = length * breadth;

  //factory constructor
  factory Area(int length, int breadth) {
    //invoke private constructor.
    return Area._interal(length, breadth);
  }
}

void main() {
  Area area = Area(10, 20);
  print("length ${area.length} breadth ${area.breadth} area ${area.area}");
}
...................................................................................
			  Constructor Redirections

calling from one constructor to another constructor.

constructors are called with in same class using "this"
constructors are called in inheritance class using "super"
 
class Point {
  double x, y;

  Point(this.x, this.y);

  //redirect to constructor
  Point.createPoint(double x, double y) : this(x, y);
}

void main() {
  Point p = Point.createPoint(23, 34);
  print(p.x);
  print(p.y);

}
.....................................................................................
			 Hierachy : IS-A and Has-A

IS-A: Inheritance
..................
 Share common code across the multiple classes.

Implementation:
1.concrete class inheritance
2.Interface based inheritance
3.Abstract class based inheritance
4.mixin based inheritance.

1.concrete class inheritance
 
extends keyword to connect base and child class.
class Person {
  String? name;
  int? age;

  Person(this.name, this.age);
}

class Student extends Person {
  //child property
  String? schoolName;

  Student({String? name = "name", int? age = 5, this.schoolName = "school"})
      : super(name, age);
}

void main() {
  Student student = Student();
  print("name ${student.name}");
  print("age ${student.age}");
  print("schoolName ${student.schoolName}");
}
....................................................................................
				Polymorphism and inheritance
....................................................................................


Super class methods inside child class;
class Animal {
  eat() {
    print("animal eats");
  }
}

class Dog extends Animal {
  bark() {
    print("dog is barking");
  }
}

void main() {
   Dog dog = Dog();
   dog.eat();
   dog.bark();
}

Overriding:
class Animal {
  void eat() {
    print("animal eats");
  }
}

class Dog extends Animal {
  bark() {
    print("dog is barking");
  }

  @override
  void eat() {
    print("dog eats");
  }
}

void main() {
  Dog dog = Dog();
  dog.eat();
  dog.bark();
}

Program to Super type:

"The type of the variable can be same type or its super type"

Type and implementation is same : Program to concrete type
 Dog dog = Dog();

"Type of variable here is super type: Program to super type"
Animal animal = Dog();

As per oo, the compiler during compile time ,it checkes "the type"

  Animal animal = Dog();
  animal.eat();

 here eat method belongs to Animal type, so that compiler does not give any error

  Animal animal = Dog();
  animal.eat();
  animal.bark();

 here "bark" method will give compile time error, because compiler always looks type, bark methods does not belong to Animal type.

         "During compile time , the compiler checks the left side(Type)"	
	 "During runtime ,the compiler checks right side(object)"

What if i want to call method on child object using parent reference?

 "Type casting" 
class Animal {
  void eat() {
    print("animal eats");
  }
}

class Dog extends Animal {
  bark() {
    print("dog is barking");
  }

  @override
  void eat() {
    print("dog eats");
  }
}

void main() {
  Dog dog = Dog();
  dog.eat();
  dog.bark();

  //
  Animal animal = Dog();
  animal.eat();
  //animal.bark();
  //here we convert animal into dog.
  Dog tmpDog = animal as Dog;
  tmpDog.bark();
}
.................

How to call base class methods using super keyword.
class Animal {
  void eat() {
    print("animal eats");
  }
}

class Dog extends Animal {
  bark() {
    print("dog is barking");
  }

  @override
  void eat() {
    print("dog eats");
    super.eat();
  }
}

void main() {
  Dog dog = Dog();
  dog.eat();
  dog.bark();

  //
  Animal animal = Dog();
  animal.eat();
  //animal.bark();
  //here we convert animal into dog.
  Dog tmpDog = animal as Dog;
  tmpDog.bark();
}
................................

2.Interface based inheritance

An interface means common behaviour across multiple different class hierachies.

Declaring interface 
 -> in dart no special interface keyword, rather we use same class
implementing interface	 
 -> instead of using extends keyword ,we use implements keyword .
 

class Animal {
  void eat() {
     print("Animal eat");
  }
}
class Dog implements Animal {
  @override
  void eat() {
    print("Dog eat");
  }

}
void main(){
  Animal dog = Dog();
  dog.eat();
}

What if i want only declare methods in parent class not ready to implement.

Abstract classes

abstract class Animal {
  void eat();
  void canWalk();
  void canRun();
}

class Dog implements Animal {
  @override
  void eat() {
    print("Dog eat");
  }

  @override
  void canRun() {
    print("Dog can run");
  }

  @override
  void canWalk() {
    // TODO: implement canWalk
    print("Dog can walk");
  }
}

void main() {
  Animal dog = Dog();
  dog.eat();
  dog.canWalk();
  dog.canRun();
}
..................

Implementing multiple super class with single child class

abstract class Animal {
  void eat();
}

abstract class Walking {
  void canWalk();
}

abstract class Running {
  void canRun();
}

class Dog implements Animal, Walking, Running {
  @override
  void eat() {
    print("Dog eat");
  }

  @override
  void canRun() {
    print("Dog can run");
  }

  @override
  void canWalk() {
    // TODO: implement canWalk
    print("Dog can walk");
  }
}

void main() {
  var dog = Dog();
  dog.eat();
  dog.canWalk();
  dog.canRun();
}
..................................................................................
				Mixins
...................................................................................

Mixins are similar to classes and abstract classes but it looks exactly like interfaces in other languages.

mixins are way of resuing code in multiple classes. mixins are declared using the keyword mixin followed by mixin name.
mixin can be inherited "with and on " keywords

Rules:
1.mixin cant be instiated.
2.Mixin has no constructor and cant be extended
3.you can use multiple mixins on single class.


mixin Mixin1{}
mixin Mixin2{}
mixin Mixin3{}
mixin Mixin4{}

class A with Mixin1,Mixin2,Mixin3,Mixin4{}


mixin Electric {
  void electric() {
    print("Electric");
  }
}
mixin Petrol {
  void petrol() {
    print("Petrol");
  }
}

class Car with Electric, Petrol {}

void main() {
  var car = Car();
  car.electric();
  car.petrol();
}
.....................................................................................
				Generics and Collections
.....................................................................................

if you container objects and methods, which may take any type(Object) if you want restrict to particular type , we can use generics.

Use i want to create a class to accept a specific type like int,double.

Without Generics:
//Create a class which accepts only Integer
class IntData {
  int? data;

  IntData(this.data);
}
//Create a class which accepts only Double

class DoubleData {
  double? data;

  DoubleData(this.data);
}

void main() {
  IntData intData = IntData(10);
  DoubleData doubleData = DoubleData(34.56);
}

In this code we need to duplicate classes for every type....

How to create a class which accept the data what i want?
  "The soultion is Generic" class

Generic class Syntax:

class ClassName<T> {

}
T - means type. 

//Create a class which accepts only Integer
class Data<T> {
  T? data;

  Data(this.data);
}

void main() {
  //Data intData = Data<int>(10.34);
  Data intData = Data<int>(10);
}

Conventions in Generics:

T - Type
e - Element
K-  Key
V - Value

//Create a class which accepts only Integer
class Data<T> {
  T? data;

  Data(this.data);
}

class Map<K, V> {
  K? Key;
  V? Value;

  Map(this.Key, this.Value);
}

void main() {
  //Data intData = Data<int>(10.34);
  Data intData = Data<int>(10);
  Map map = Map<int, String>(1, "Value");
}

Generic Methods:
...............
//Create a class which accepts only Integer

class Adder {
  T add<T, E>(T value1) {
    return value1;
  }
}

void main() {
  //Data intData = Data<int>(10.34);
  Data intData = Data<int>(10);
  Map map = Map<int, String>(1, "Value");

  Adder adder = Adder();
  adder.add<int, int>(10);
}
.......................................................................

I want to create generic class which accept the particular family of type.

i want to create generic class which accepts only numbers(int,double...)

//Create a class which accepts only Integer
class Data<T> {
  T? data;

  Data(this.data);
}

class Map<K, V> {
  K? Key;
  V? Value;

  Map(this.Key, this.Value);
}

class Adder {
  T add<T, E>(T value1) {
    return value1;
  }
}

//Generic with Restrictions
class MyNumber<T extends num> {
  T data;

  MyNumber(this.data);

  num add<T extends num>(T value1, T value2) {
    return value1 + value2;
  }
}

void main() {
  //Data intData = Data<int>(10.34);
  Data intData = Data<int>(10);
  Map map = Map<int, String>(1, "Value");

  Adder adder = Adder();
  adder.add<int, int>(10);

  // MyNumber<String>("Helllo");
  // MyNumber<bool>(true);
  MyNumber(10);
  MyNumber(20.45);
  // MyNumber(true);
  MyNumber myNumber = MyNumber(0);
  print(myNumber.add(13, 10));
}
.....................................................................................	
				 Collections

Dart uses different types of collections
All Collections powered with Generics

1.List
2.Set 
3.Map

List:
 List is similar to arrays in other programming languages
 List is dynamic and object

class Product {
  int productId;
  String productName;
  double price;

  Product(this.productId, this.productName, this.price);
}

void main() {
  //immutable list
  const List<int> numList = [1, 2, 3, 4];
  for (int value in numList) {
    print(value);
  }
  numList.forEach((element) {
    print(element);
  });
  List<Product> products = [
    Product(1, "p1", 1334.0),
    Product(2, "p2", 34412.0),
    Product(3, "p3", 12121.0)
  ];
  for (Product product in products) {
    print("${product.productId} ${product.productName} ${product.price}");
  }
}
.....................................................................................
Set:
 => Set and List is same but Set does not allow duplicates...

void main() {
  Set<String> fruits = {"Apple", "Apple", "Orange", "Mango"};
  for (String fruit in fruits) {
    print(fruit);
  }
}
....................

Map:
  => Key value pair

void main() {
  Map<String, String> countriesAndCapital = {
    "India": "New Delhi",
    "USA": " Washing Don DC",
    "UK": "London"
  };
  print(countriesAndCapital);
}
....................................................................................
			 Records
....................................................................................
Records are an anonymous,immutable,aggregate type. Like other collection types, they let you bundle multiple objects. 
Collections are dynamic types, but Records are fixed.

Record syntax:
 var record = ('hello',a:2,b:true,'last')


Without Records if you want to return multiple values from the function , you have use Object

eg:
class Location {
  int lat;
  int lng;

  Location(this.lat, this.lng);
}

Location getLocation() {
  int lat = 10;
  int lng = 9223;
  return Location(lat, lng);
}

void main() {
  Location location = getLocation();
  print(location.lat);
  print(location.lng);
}

Records are going to replace "class" still you can return multiple values from function.


void main() {
  (int, int) getMyLocation() {
    int lat = 10;
    int lng = 9223;
    return (lat, lng);
  }
  var location = getMyLocation();
  print(location);
}

How to access record fileds?

 Dart exposes special "getter functions" $1 means first value $2 means second value, and so on ,  $n other values.

// class Location {
//   int lat;
//   int lng;
//
//   Location(this.lat, this.lng);
// }
//

void main() {
  // (int, int) getMyLocation() {
  //   int lat = 10;
  //   int lng = 9223;
  //   return (lat, lng);
  // }
  (int, int) getMyLocation() {
    int lat = 10;
    int lng = 9223;
    return (lat, lng);
  }

  var location = getMyLocation();
  print(location);
  print(location.$1);
  print(location.$2);
  //Destructuring
  final (lat, lng) = getMyLocation();
  print("lat=$lat lng=$lng");
}
.....................................................................................
			 Exception Handling
.....................................................................................
Dart language can throw and catch exceptions.
Exception provides to handle runtime errors.
Dart Provides two base classes to handle errors

1.Exception
2.Error

Exception is base class For all exceptions 

Common Sub Classes:
1.TimeoutException
2.IOException

Common Sub class for Errors:
1.StackOverFlowError
2.TypeError
3.ArgumentError

Keywords to handle Exceptions:

1.throw 
2.catch
3.try
4.on
5.finally

..
Risky code always goes inside try block...
Risky code means that code may or may not cause runtime error. if error occurs how to handle that.
catch block will have error handling code like reporting errors in console or sending to error reporting softwares...

Use case : Handling Generic Exception
void main() {
  try {
     int result = 12 ~/ 0;
     print("result $result");
  } catch (e) {
    print("Handing error");
    print(e);
  }
}

Use case 2:Handling particular Exception
  try {
    int result = 12 ~/ 0;
    print("result $result");
  } on IntegerDivisionByZeroException {
    print("Handing error");
  }

Use case 3: Handling two generic exceptions;
try {
     int result = 12 ~/ 0;
     print("result $result");
  } catch (e,s) {
    print("Handing error");
    print(e);
  }

Use case 4: handling finally
void main() {
  //Here catch block will handle any type of Exception
  // try {
  //    int result = 12 ~/ 0;
  //    print("result $result");
  // } catch (e) {
  //   print("Handing error");
  //   print(e);
  // }
  //if i want to handle particular exception
  // try {
  //   int result = 12 ~/ 0;
  //   print("result $result");
  // } on IntegerDivisionByZeroException {
  //   print("Handing error");
  // }
  //Multiple generic excepiton
  try {
    int result = 12 ~/ 0;
    print("result $result");
  } catch (e, s) {
    print("Handing error");
    print(e);
  } finally {
    print("finally");
  }
}

Custom Exceptions:
..................
 We can create ourown biz exceptions.
class DepositException implements Exception {
  String errorMessage() {
    return 'You Cant enter Amount less than 0';
  }
}

void deposit(int amount) {
  if (amount <= 0) {
    throw DepositException();
  }
  print("deposited amount $amount");
}

void main() {
  try {
    deposit(100);
    deposit(-10);
  } on DepositException catch (e) {
    print(e.errorMessage());
  }
}
..................................................................................
				Dart Async Programming
..................................................................................

When you call any method/fun to perform some cpu intensive task, generally that function blocks the current thread.
lets say if you read a file from the disk or data from the network, if you are doing some animations, these task takes more time than expected.
Generally User interface applications, runs in thread called main thread or ui thread.
from the ui thread if you start doing any network operation which blocks the main/ui thread so that the UI would be unresponsive.

if UI thread is blocked because of any io operations, user cant continue to work with app, which degrades the user experience.

In order to improve the user expereince, we should not do any io task in the UI Thread, rather we need to "isloate" the task into separate thread, later that thread need to communicate with main thread.

Dart provides  high level api abstraction to implement such non blocking or async programming technique.

1.Future 
2.Async...await 
3.Stream
4.isloates - new feature - low level

Future:
  In Dart, Future is object represents a value or error that is not yet available.
It is used to represent a potential value, or error that will available at some time in the future.

//Future value
Future<String> getValue() {
  return Future.value("Hello,I am async value");
}

void main() {
  print("start");
  getValue().then((value) => print(value));
  print("going on");
  print("end");
}

Handling errors and value:
//Future value
Future<String> getValue() {
  return Future.value("Hello,I am async value");
}

Future<String> getError() {
  return Future.error("somthing went wrong!");
}

void main() {
  print("start");
  getValue().then((value) => print(value));
  getError().then((value) => print(value));
  print("going on");
  print("end");
}
...........
Future with Delay:
..................
Future<String> getUserName() {
  return Future.delayed(Duration(seconds: 2), () => "Subramnaian");
}
void main(){
  print("start");
  getUserName().then((value) => print(value));
  print("end");
}
...................................................................................
		          Async and await 
...................................................................................

Async...await is not new concept rather which simplifies the Future subscriptions.
async...await are keywords allows us to write async code that looks and behaves like sync code, making it easier to read.

async keyword:
  The function which resolves a future


//Future value
Future<String> getValue() {
  return Future.value("Hello,I am async value");
}

normal function
void getData(){ 
   getValue().then(value=>print(value)) ;  
}

async 
void getData() async { 
  try{
   final data = await getValue();
  }
  catch(e) {

  }
}

...
Future<String> getUserName() {
  return Future.delayed(Duration(seconds: 2), () => "Subramanian");
}
Future<String> getMessage(String name) {
  return Future.delayed(Duration(seconds: 3), () => "Hello $name");
}

void getData() async {
  try {
    String name = await getUserName();
    String res =  await getMessage(name);
    print(res);
  } catch (e) {
    print(e);
  }
}

void main() {
  print("start");
  getData();
  print("end");
}
..................................................................................
				 Stream
..................................................................................

A Stream is sequence of asynchronous events representing multiple values that will arrive over period of time.

A Future returns async value but single value.

		Single Value                  Zero or MoreValues

Sync            int                           Iterator

Async           Future<T>                     Stream<T>

How to create Stream?
......................
Stream<String> getUsers() {
  List<String> users = ["a", "b", "c", "d", "e"];
  return Stream.fromIterable(users);
}

void main() async {
  // print("start");
  // getUsers().listen((event) {
  //   print(event);
  // });
  await for (var event in getUsers()) {
    print(event);
  }
  // print("end");
}
....................................................................................
			 packages
....................................................................................

How to share code within app or across app?

In dart all the code within dart file is available with in the dart file?

What if i want to share code from one dart file into another?

packages.

Types of packages
1.custom package
2.dart or flutter built in packages
3.third party

pubspec.yaml file 
 which describes the packages
Your dart app itself is package.

name: myapp
description: A sample command-line application.
version: 1.0.0
# repository: https://github.com/my_org/my_repo

environment:
  sdk: ^3.1.2

# Add regular dependencies here.
dependencies:
  # path: ^1.8.0

dev_dependencies:
  lints: ^2.0.0
  test: ^1.21.0


dependencies means what are the dependency packages used for dev and production.
dev dependencies means what are the dependency packages used for dev only.


How to publish or add new dependency?

dart pub  - dependency management tool

https://pub.dev/

How to install new depedency?
dart pub add vector_math        
Resolving dependencies... 
  coverage 1.6.3 (1.6.4 available)
  test 1.24.6 (1.24.7 available)
  test_core 0.5.6 (0.5.7 available)
+ vector_math 2.1.4
  vm_service 11.10.0 (12.0.0 available)
Changed 1 dependency!

How to use packages into our app? importing libs from the packages

import 'package:packageName/fileName.dart'
import 'package:packageName/fileName.dart' as myalise

import 'package:vector_math/vector_math.dart';

void main() {
  Vector3 x = Vector3.zero(); // Zero vector
  Vector4 y = Vector4.all(4.0); // Vector with 4.0 in all lanes
  x.zyx = y.xzz; // Sets z,y,x the values in x,z,z
  print(x.zyx);
}

Custom Packages.

the code must go inside lib dir

lib/add.dart
int add(int a, int b) {
  return a + b;
}

bin/main.dart
import 'package:vector_math/vector_math.dart';
import 'package:myapp/add.dart' as adder;

void main() {
  Vector3 x = Vector3.zero(); // Zero vector
  Vector4 y = Vector4.all(4.0); // Vector with 4.0 in all lanes
  x.zyx = y.xzz; // Sets z,y,x the values in x,z,z
  print(x.zyx);
  print(adder.add(12, 33));
}
.....................................................................................




				



















































			





 




























